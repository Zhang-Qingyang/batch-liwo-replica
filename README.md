# Batch-LIWO复刻项目

尝试根据公开信息复刻中科大RoboWalker战队2025赛季未开源的Batch-LIWO里程计。

本项目Fork自point_lio_ros2，感谢point_lio原作者和ros2移植开发者的贡献，以及中科大的开源。

## 资料汇总

1.论坛开源提供的技术报告和Batch-LIWO论文：https://bbs.robomaster.com/article/803727

2.RMUC2025青工会技术分享：https://www.bilibili.com/video/BV1E44RzqEoy

3.Point-LIO原始论文

## 原理分析

截至目前（2025/12/2），中科大25赛季哨兵导航仍然没有任何一项技术的代码仓库有开源更新，所以只能从point_lio开始自己手搓。

由于要给原项目动手术，我们先从Point-LIO原项目的原理和整体工程组织开始，先给一个非常意识流的总体描述

Point-LIO的主要创新点在于Point Wise更新。相比其他LIO的逐帧更新（10Hz左右），一方面能够避免帧内运动畸变，另一方面极大提高输出带宽（200000Hz）。提高了鲁棒性，能够应对哨兵被撞等速度突变。

同时，Point-LIO相比FAST-LIO等传统方法，加入了状态量扩充。也就是，之前的Kalman滤波状态量只有位置、速度、姿态等，IMU读出的角速度、加速度等直接当成input，如果出现IMU爆量程（动的太快，即所谓saturation）等现象就会导致观测异常。Point-LIO在状态量中直接加入了角速度和加速度，如果IMU数据异常就降低置信度，用lidar的点云数据估计角速度和加速度，一定程度上提高了稳定性。而且因为采用逐点更新，lidar更新频率远超IMU，这种方法就可以在IMU没数据的时候用lidar数据估计相关运动学状态。

然后仔细分析一下整个算法流程。

Point-LIO（和所有基于滤波的slam）的算法核心在于两个步骤（其实就是Kalman滤波的两个步骤），预测和修正。用IMU获取运动学数据（角速度、加速度），预测下一刻的位姿，然后用lidar点计算残差、修正位置和协方差矩阵。这里就引出了point-lio和fast-lio等传统的（此处指frame wise的）slam的主要区别。传统的slam获取点云的途径是整帧获取，假设雷达坐标系在获取整帧的一个极短时间片内基本匀速运动，然后根据每个点云的时间戳，用imu获取的位姿数据修正帧内运动畸变，把所有点的位姿全部变换到同一个时间戳下，这种方式的缺点主要在于如果车被撞了点云就乱了，而且雷达装底盘上就没法小陀螺，因为动的太快导致没法修正运动畸变。point-lio直接采用单个点数据来修正状态量估计结果，这样就直接消灭了帧内运动畸变的问题，因为连帧都没了。同时，由于这个改动，相当于imu更新频率（200Hz+）远远落后于lidar点更新速率（200000Hz+），差距达到了1000倍，这种情况下仍然使用原先的方法肯定是不行的。为此point-lio在状态量中直接加入了角速度和加速度（本来要从imu拿到的数据），在没有imu数据到来的时候，直接用上一刻的角速度和加速度估计下一刻的运动状态（低置信度），再用lidar点修正，在有imu数据到来的时候，就用imu数据直接更新运动状态（高置信度）。

借助这种机制，point_lio同时具备了“高带宽”和“高鲁棒”两种特性，比如现在车被撞了一下，传统lio必须等到下一帧imu数据到了，才知道加速度变了，但是point-lio通过带宽极高的lidar点修正，就能够瞬间感知到运动状态的变化。



batch-liwo在point_lio的基础上开发，主要3个创新点，

1.将逐点更新改为批量（Batch）更新

2.在Point-LIO的基础上融合轮速数据

3.（在电控层实现的）线性Kalman底盘速度观测器

## 开发计划

## 进度更新

2025/12/3

1.fork point_lio_ros2项目，准备开始开发

2.原项目没有完整支持MID360，重写了preprocess.cpp中部分内容，支持获取MID360提供的标准PointCloud2点云

目前已经能够跑通原项目，定位等功能均正常，实测平均CPU占用率（仅运行Point-LIO）在30%上下，偶尔有一两个核会飘到50%以上

2025/12/4

1.完整读了一遍Point-LIO原论文，跟着推了一遍公式，更新了一些原理分析

2.